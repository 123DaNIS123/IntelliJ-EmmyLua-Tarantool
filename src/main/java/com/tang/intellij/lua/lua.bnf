{
  parserClass="com.tang.intellij.lua.parser.LuaParser"

  implements="com.tang.intellij.lua.psi.LuaPsiElement"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Lua"
  psiImplClassSuffix="Impl"
  psiPackage="com.tang.intellij.lua.psi"
  psiImplPackage="com.tang.intellij.lua.psi.impl"
  psiImplUtilClass="com.tang.intellij.lua.psi.LuaPsiImplUtil"

  parserUtilClass="com.tang.intellij.lua.psi.LuaParserUtil"
  elementTypeHolderClass="com.tang.intellij.lua.psi.LuaTypes"
  elementTypeClass="com.tang.intellij.lua.psi.LuaElementType"
  elementTypeFactory="com.tang.intellij.lua.lang.LuaParserDefinition.createType"
  tokenTypeClass="com.tang.intellij.lua.psi.LuaTokenType"
  tokenTypeFactory="com.tang.intellij.lua.lang.LuaParserDefinition.createToken"
  parserImports = "static com.intellij.lang.WhitespacesBinders.*"

  tokens = [
        /* Keywords */
        AND = "and"
        BREAK = "break"
        DO = "do"
        ELSE = "else"
        ELSEIF = "elseif"
        END = "end"
        FALSE = "false"
        FOR = "for"
        FUNCTION = "function"
        IF = "if"
        IN = "in"
        LOCAL = "local"
        NIL = "nil"
        NOT = "not"
        OR = "or"
        REPEAT = "repeat"
        RETURN = "return"
        THEN = "then"
        TRUE = "true"
        UNTIL = "until"
        WHILE = "while"
        SELF = "self"

        SHEBANG = "#!"
        ELLIPSIS = "..."
        CONCAT = ".."
        EQ = "=="
        GE = ">="
        LE = "<="
        NE = "~="
        MINUS = "-"
        PLUS = "+"
        MULT = "*"
        MOD = "%"
        DIV = "/"
        ASSIGN = "="
        GT = ">"
        LT = "<"
        LPAREN = "("
        RPAREN = ")"
        LBRACK = "["
        RBRACK = "]"
        LCURLY = "{"
        RCURLY = "}"
        GETN = "#"
        COMMA = ","
        SEMI = ";"
        COLON = ":"
        DOT = "."
        EXP = "^"

        SHORT_COMMENT="SHORT_COMMENT"
        DOC_COMMENT="DOC_COMMENT"
        BLOCK_COMMENT="BLOCK_COMMENT"
        ID="regexp:[A-Za-z_][A-Za-z0-9_]*"
        NUMBER="NUMBER"
        STRING = "STRING"
  ]

  implements("tableConstructor") = "com.tang.intellij.lua.psi.LuaIndentRange"
  hooks("forAStat|forBStat") = [leftBinder="MY_LEFT_COMMENT_BINDER"]
  implements("forAStat|forBStat") = "com.tang.intellij.lua.psi.LuaIndentRange, com.tang.intellij.lua.psi.LuaParametersOwner, com.tang.intellij.lua.psi.LuaCommentOwner"
  hooks("localDef|assignStat") = [leftBinder="MY_LEFT_COMMENT_BINDER"]
  implements("localDef|assignStat") = "com.tang.intellij.lua.psi.LuaDeclaration"
  hooks("globalFuncDef|localFuncDef|classMethodDef") = [leftBinder="MY_LEFT_COMMENT_BINDER"]
  hooks("fieldList") = [leftBinder="GREEDY_LEFT_BINDER" rightBinder="GREEDY_RIGHT_BINDER"]
  implements("expr|funcCall") = "com.tang.intellij.lua.psi.LuaExpression"
  implements("doStat|whileStat|repeatStat|ifStat|funcBody") = "com.tang.intellij.lua.psi.LuaIndentRange"
  extends(".*Expr") = expr
}

luaFile ::= stat_or_comment*

private comment ::= SHORT_COMMENT | DOC_COMMENT | BLOCK_COMMENT
private stat_or_comment ::= comment | stat ';'?
private chunk ::= stat_or_comment* (lastStat ';'?)?
block ::= chunk
private lazy_block ::= <<lazyBlock>>

private stat ::=
    funcCallExpr |
    assignStat |
    doStat |
    whileStat |
    repeatStat |
    ifStat |
    forAStat |
    forBStat |
    classMethodDef |
    globalFuncDef |
    localFuncDef |
    localDef |
    lastStat {
        recoverWhile = stat_recover
    }
private stat_recover ::= !(ID
    | ',' | ';'
    | 'local' | 'do' | 'while' | 'repeat' | 'function' | 'if' | 'for' | 'return' | break
    | nil | true | false | STRING | NUMBER | SELF)

assignStat ::= varList '=' exprList { pin = 1 methods = [getComment] }
doStat ::= 'do' lazy_block 'end' { pin = 1 }
whileStat ::= 'while' expr 'do' lazy_block 'end' { pin = 1 }
repeatStat ::= 'repeat' lazy_block 'until' expr { pin = 1 }
ifStat ::= 'if' expr 'then' lazy_block ('elseif' expr 'then' lazy_block)* ('else' lazy_block)? 'end' { pin = 1 }
forAStat ::= 'for' paramNameDef '=' expr ',' expr (',' expr)? 'do' lazy_block 'end' { pin = 3 methods = [getComment getParamNameDefList] }
forBStat ::= 'for' parList 'in' exprList 'do' lazy_block 'end' { pin = 1 methods = [getComment] }

globalFuncDef ::= 'function' ID funcBody {
    pin = 1
    implements = [
        "com.tang.intellij.lua.psi.LuaFuncBodyOwner"
        "com.tang.intellij.lua.psi.LuaDeclaration"
        "com.intellij.psi.PsiNameIdentifierOwner"
    ]
    methods = [
        getComment
        getPresentation
        getParamNameDefList
        getNameIdentifier
        setName
        getName
        getTextOffset
        toString
    ]
    stubClass = "com.tang.intellij.lua.stubs.LuaGlobalFuncStub"
}

private checkFuncPrefix ::= ID ('.' | ':') ID

left funcPrefixRef ::= '.' <<repeat checkFuncPrefix 1>> nameRef
classMethodName ::=  nameRef (funcPrefixRef)* (('.' ID) | (':' ID)) { pin = 3 }
classMethodDef ::= 'function' classMethodName funcBody {
    pin = 2
    implements = [
        "com.tang.intellij.lua.psi.LuaFuncBodyOwner"
        "com.tang.intellij.lua.psi.LuaDeclaration"
        "com.tang.intellij.lua.psi.LuaClassMember"
        "com.intellij.psi.PsiNameIdentifierOwner"
    ]
    stubClass = "com.tang.intellij.lua.stubs.LuaClassMethodStub"
    methods = [
        getComment
        getClassType
        getClassName
        getParamNameDefList
        getNameIdentifier
        setName
        getName
        getTextOffset
        toString
    ]
}

localFuncDef ::= 'local' 'function' ID funcBody {
    pin = 2
    implements = [
        "com.tang.intellij.lua.psi.LuaFuncBodyOwner"
        "com.tang.intellij.lua.psi.LuaDeclaration"
        "com.intellij.psi.PsiNameIdentifierOwner"
    ]
    methods = [getComment getParamNameDefList getNameIdentifier setName getName getTextOffset]
}
localDef ::= 'local' nameList ('=' exprList)? {
    pin = 1
    methods = [getComment]
}

returnStat ::= return exprList?
breakStat ::= break
private lastStat ::= returnStat | breakStat

varList ::= var (',' var)*

nameList ::= nameDef (',' nameDef)*

exprList ::= (expr ',')* expr { methods = [guessTypeAt] }

valueExpr ::= nil | false | true | NUMBER | STRING | "..." | closureFuncDef | tableConstructor | var | parenExpr

// 最终产生 call expr | index expr | nameRef
var ::= callOrIndexExpr | nameRef {
    methods = [
        toString
        resolveType
        getFieldName

        getName
        setName
        getNameIdentifier
        getTextOffset
    ]
    implements = [
        "com.tang.intellij.lua.psi.LuaClassField"
        "com.intellij.psi.PsiNameIdentifierOwner"
    ]
    stubClass = "com.tang.intellij.lua.stubs.LuaVarStub"
}

expr ::= unaryExpr | binaryExpr | valueExpr { mixin = "com.tang.intellij.lua.psi.impl.LuaExpressionImpl" }

parenExpr ::= '(' expr ')' { pin = 1 }
unaryExpr ::= unaryOp expr { pin = 1 }
binaryExpr ::= valueExpr binaryOp expr { pin = 2 }

left indexExpr ::= '[' expr ']' | '.' ID {
    pin(".*") = 1
    methods = [guessPrefixType]
}

arg_expr_list ::= (expr ',')* (expr |& ')') { extends = exprList elementType = exprList }
args ::=  '(' (arg_expr_list)? ')' | tableConstructor | STRING { pin(".*") = 1 }
private callExpr1 ::= args
private callExpr2 ::= '.' ID args
private callExpr3 ::= ':' ID args { pin = 1 }
left callExpr ::= callExpr1 | callExpr2 | callExpr3 { methods = [guessPrefixType resolveFuncBodyOwner getFirstStringArg] }

private suffixExpr ::=  callExpr | indexExpr
private prefixExpr ::= parenExpr | nameRef
// 最终产生 callExpr | indexExpr
private callOrIndexExpr ::= prefixExpr suffixExpr+
// callExpr
private funcCallExpr ::= callOrIndexExpr <<checkCallExpr>>

closureFuncDef ::= 'function' funcBody {
    pin = 2
    implements = "com.tang.intellij.lua.psi.LuaFuncBodyOwner"
    methods = [getParamNameDefList]
}

funcBody ::= '(' (parList)? ')' lazy_block? 'end' { pin = 3 }

private parList ::= paramNameDef (',' paramNameDef)* (',' '...')? | '...'

tableConstructor ::= '{' fieldList '}' {
    pin = 1
    methods = [findField toString]
    stubClass = "com.tang.intellij.lua.stubs.LuaTableStub"
}

fieldList ::= (tableField (tableFieldSep tableField)* (tableFieldSep)?)?

tableField ::= '[' expr ']' '=' expr | ID '=' expr | expr {
    methods = [
        getNameIdentifier
        setName
        getName
        getTextOffset

        getFieldName
        resolveType
        nameDef = "tableFieldNameDef"
    ]
    implements = [
        "com.tang.intellij.lua.psi.LuaClassField"
        "com.intellij.psi.PsiNameIdentifierOwner"
    ]
}

tableFieldSep ::= ',' | ';'

binaryOp ::= '+' | '-' | '*' | '/' | '^' | '%' | '..' |
     '<' | '<=' | '>' | '>=' | '==' | '~=' |
     'and' | 'or'

unaryOp ::= '-' | 'not' | '#'

fake name ::= ID {
    implements = [
        "com.tang.intellij.lua.psi.LuaNamedElement"
    ]
    methods = [setName getName]
}
nameDef ::= ID {
    implements = ["com.tang.intellij.lua.psi.LuaTypeResolvable" "com.intellij.psi.PsiNameIdentifierOwner"]
    methods = [resolveType getNameIdentifier]
    extends = name
}
nameRef ::= ID | SELF {
    implements = "com.tang.intellij.lua.psi.LuaNamedElement"
    methods = [setName getName getReference resolve resolveType]
}
paramNameDef ::= ID | SELF {
    extends = nameDef
}