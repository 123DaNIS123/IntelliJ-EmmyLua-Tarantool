{
  parserClass="com.tang.intellij.lua.parser.LuaParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Lua"
  psiImplClassSuffix="Impl"
  psiPackage="com.tang.intellij.lua.psi"
  psiImplPackage="com.tang.intellij.lua.psi.impl"

  elementTypeHolderClass="com.tang.intellij.lua.psi.LuaTypes"
  elementTypeClass="com.tang.intellij.lua.psi.LuaElementType"
  tokenTypeClass="com.tang.intellij.lua.psi.LuaTokenType"

  tokens = [
        /* Keywords */
        AND = "and"
        BREAK = "break"
        DO = "do"
        ELSE = "else"
        ELSEIF = "elseif"
        END = "end"
        FALSE = "false"
        FOR = "for"
        FUNCTION = "function"
        IF = "if"
        IN = "in"
        LOCAL = "local"
        NIL = "nil"
        NOT = "not"
        OR = "or"
        REPEAT = "repeat"
        RETURN = "return"
        THEN = "then"
        TRUE = "true"
        UNTIL = "until"
        WHILE = "while"

        SHEBANG = "#!"
        ELLIPSIS = "..."
        CONCAT = ".."
        EQ = "=="
        GE = ">="
        LE = "<="
        NE = "~="
        MINUS = "-"
        PLUS = "+"
        MULT = "*"
        MOD = "%"
        DIV = "/"
        ASSIGN = "="
        GT = ">"
        LT = "<"
        LPAREN = "("
        RPAREN = ")"
        LBRACK = "["
        RBRACK = "]"
        LCURLY = "{"
        RCURLY = "}"
        GETN = "#"
        COMMA = ","
        SEMI = ";"
        COLON = ":"
        DOT = "."
        EXP = "^"

        WS = "WS"
        LUADOC_COMMENT = "LUADOC_COMMENT"
        NL_BEFORE_LONGSTRING = "NL_BEFORE_LONGSTRING"
        WRONG = "WRONG"
        SHORTCOMMENT = "SHORTCOMMENT"
        LONGCOMMENT_BEGIN = "LONGCOMMENT_BEGIN"
        LONGCOMMENT = "LONGCOMMENT"
        LONGCOMMENT_END = "LONGCOMMENT_END"
        LONGSTRING_BEGIN = "LONGSTRING_BEGIN"
        LONGSTRING = "LONGSTRING"
        LONGSTRING_END = "LONGSTRING_END"
  ]
}
luaFile ::= stat*

chunk ::= (stat ';'?)* (lastStat ';'?)?

block ::= chunk

stat ::=
    assignStat |
    funcCall |
    doStat |
    whileStat |
    repeatStat |
    ifStat |
    forAStat |
    forBStat |
    globalFuncDef |
    localFuncDef |
    localDef

assignStat ::= varList '=' exprList
doStat ::= 'do' block 'end'
whileStat ::= 'while' expr 'do' block 'end'
repeatStat ::= 'repeat' block 'until' expr
ifStat ::= 'if' expr 'then' block ('elseif' expr 'then' block)* ('else' block)? 'end'
forAStat ::= 'for' NAME '=' expr ',' expr (',' expr)? 'do' block 'end'
forBStat ::= 'for' nameList 'in' exprList 'do' block 'end'
globalFuncDef ::= 'function' funcName funcBody
localFuncDef ::= 'local' 'function' NAME funcBody
localDef ::= 'local' nameList ('=' exprList)?

lastStat ::= return exprList? | break

funcName ::= NAME ('.' NAME)* (':' NAME)?

varList ::= var (',' var)*

nameList ::= NAME (',' NAME)*

exprList ::= (expr ',')* expr

value ::= nil | false | true | NUMBER | STRING | "..." | func | tableConstructor | funcCall | var | '(' expr ')'

expr ::= unop expr | value (binop expr)?

prefixExpr ::= '(' expr ')' | NAME

indexExpr ::= '[' expr ']' | '.' NAME

callExpr ::= args | ':' NAME args

suffixExpr ::= callExpr | indexExpr

var ::= prefixExpr (suffixExpr)* indexExpr | NAME

funcCall ::= prefixExpr (suffixExpr)* callExpr

args ::=  '(' (exprList)? ')' | tableConstructor | STRING

func ::= 'function' funcBody

funcBody ::= '(' (parList)? ')' block? 'end'

parList ::= nameList (',' '...')? | '...'

tableConstructor ::= '{' (fieldlist)? '}'

fieldlist ::= field (fieldsep field)* (fieldsep)?

field ::= '[' expr ']' '=' expr | NAME '=' expr | expr

fieldsep ::= ',' | ';'

binop ::= '+' | '-' | '*' | '/' | '^' | '%' | '..' |
     '<' | '<=' | '>' | '>=' | '==' | '~=' |
     'and' | 'or'

unop ::= '-' | 'not' | '#'